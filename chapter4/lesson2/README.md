# 4.2 Слайсы

* Срезы в Golang представляют собой последовательности переменной длины с элементами одного типа и описываются
  как `[]T`, где `T` - тип элементов среза;
* Срез состоит из трех компонентов: `указателя на массив`, `длины` и `емкости`. Указатель указывает на первый доступный элемент массива, а длина и емкость определяют размер и максимальный размер среза соответственно;
* Срезы могут совместно использовать один и тот же базовый массив, что позволяет манипулировать субпоследовательностями элементов массива с минимальными затратами памяти;
* Оператор среза `s[i:j]` создает новый срез, ссылающийся на элементы последовательности `s` с `i` до `j-1`, при
  этом `0 <= i <= j <= cap(s)`;
* Пример объявления массива и создания срезов:
  ``` go
  months := [...]string{1: "Январь", 2: "Февраль", /*...*/, 12: "Декабрь"}
  Q2 := months[4:7]
  summer := months[6:9]
  ```
* Срезы содержат указатель на элемент массива, что позволяет изменять элементы базового массива при передаче среза в
  функцию;
* При сравнении срезов можно использовать функцию `bytes.Equal` для срезов байтов `[]byte`, но для других типов срезов необходимо выполнять сравнение вручную, создавая соответствующую функцию, например:
  ``` go
  func equal(x, y []string) bool {
    len(x) != len(y) {
	  return false
    }
    for i := range x {
      if x[i] != y[i] {
        return false
      }
    }
    return true
  }
  ```
* Использование срезов упрощает манипуляции с данными, сохраняя память и предоставляя простые и понятные методы работы с подпоследовательностями массивов;
* Срезы в Go являются косвенными элементами, что позволяет им содержать самих себя и изменяться при изменении
  содержимого базового массива;
* Функция `make` создает массив заданного размера, на который ссылается срез, и этот массив доступен только через
  возвращаемый срез `a := make([]string, 0, 3)`;
* Длина среза - количество элементов в нем, емкость среза - максимальное число элементов, которые могут быть содержимым среза;
* У срезов имеется нулевое значение `nil`, такой срез ни на что не ссылается, и его длина и емкость равны нулю;
* При сравнении срезов с помощью `==`, данные срезы сравниваются не всегда корректно, только `nil` значения могут быть сравнены. Если хотя бы один элемент или длина срезов отличаются, оператор `==` вернет `false`. Сравнение срезов с помощью оператора `==` может быть неэффективно, поскольку сравнение происходит поэлементно;
* Если необходимо сравнить содержимое срезов, нужно использовать функцию `reflect.DeepEqual` или `bytes.Equal`;
* Если срез имеет длину, равную нулю, нужно проверять его на пустоту с помощью `len(s) == 0`, а не `s == nil`;
* Для проверки равенства ссылочных типов, таких как указатели и каналы, нужно использовать операторы `==` для проверки ссылочной тождественности;
* Если необходимо добавить элементы в срез, и емкость его не достаточна, Go создаст новый массив большего размера и
  скопирует в него элементы из старого массива;
* В Go есть встроенные функции, такие как `append`, чтобы изменять размер среза;
* Срезы являются важными и удобными конструкциями в Go, их использование позволяет сделать программирование более гибким и поддерживаемым.